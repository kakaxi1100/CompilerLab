lua
原理
lua是一个解释型语言，它有一个C编写的解释器，用来做语义分析。lua经过词法分析形成分析树后（或编译成中间码），再由解释器一行行解释执行。
所以重写解释器，就能实现lua作为不同语言的扩展。
它是作为一个库来实现宿主语言扩展的。可以把它当成具有逻辑运算功能的配置表
-------------------------------------------------------------------------------------------------------------------------------------
1.程序块
	换行不起任何作用，两条语句可以用;号隔开，可以不隔开，效果是一样的。一下几种写法都是一样并且完全等价!
	a = 1
	b = a*2

	a = 1;
	b = a*2;

	a = 1; b = a*2

	a = 1 b = a*2

2.调试模式

	-i 运行完指定程序后进入调试模式
	-e 可以在-e 后直接输入代码 如：
		lua -e "print(math.sin(12))"
	-l 加载库文件 lua -l 1 (文件为1.lua)

3.词法规范

	大小写敏感

4.语法
	注释：
	单行注释：--
	块注释: --[===[内容--]===] 等号可以为0或者多个，但是必须匹配

5.类型与值
	特殊值 nil 表示空值
	访问一个未初始化的变量，得到的就是 nil
	
	8种基础类型
		nil, boolean, number, string, userdata, function, thread, table
		函数type可以返回值的类型
		print(type("Hello world")) -->string
		print(type(type(X))) -->string
	
	boolean类型
		false 和 nil 视为假， 其余的都视为真，包括空字符串和0也是视为真
	
	number类型
		number可以用16进制表示，其中p或者P 表示的时候 二进制指数
		以下写法都是正确的:
		4 0.4 4.57e-3 0.3e12 5e+20
		0xff --> 255
		0x1A3 -->419
		0x0.2 -->0.125
		0x1p-1 -->0.5
		0xa.bp2 -->42.75	
		
	string类型
		可以用单引号或者双引号来表示字符串，用#来取得字符长度
		a = "a line"
		b = 'anoter line'
		print(#a) -->6
		print(#b) -->11
		
		转义字符
		\a 响铃
		\b 退格
		\f 换页
		\n 换行
		\r 回车
		\t 水平tab
		\v 垂直tab
		\\ 反斜杠
		\" 双引号
		\' 单引号
		
		也可以用数值来转成字母，这个数值最多时有3个十进制组成，\ddd
		'alo\nl23\"'
		可以表示成
		'\97lo\10\04923"'
		a 的 ascii 的编码为 97
		\n 的编码为 10
		l 的编码为 49 但是由于l后面跟的是23也是数字，为了避免解释器解释为492所以前面要加一个0
		另外也可以用16进制来表示
		'\x61\x6c\x6f\x0a\x31\x32\x33\x22'
		
		还可以用一对方括号来自定长的字符串，[===[]===]其中等号可以是0或者多个，但是必须匹配。
		它会忽略第一行的换行，并且不会解释其中的转义序列。
		page = [====[
		<html>
		<head>
			<title></title>
		</head>
			<body>
				<a href="http://www.lua.org">lua</a>
			</body>
		</html>
		]====]
		
		\z 可以用在行末 表示第一行结束，这样在输入字符串的时候，就可以换行输入了。
		data="abcd\z
			efg"
		print(data) -->abcefg
		
		字符串在于数值进行计算的时候，会被强制转化为数字
		print("10 + 1") --> 10 + 1
		print("10"+"1") -->11.0
		print("-5.3e-10"*2) -->-1.06e-009
		print("hello"+1) --> error
		数字也可以用连字符来隐式的转换成字符串，注意 .. 两端有空格，避免被解释成小数点
		print(10 .. 20) -->1020
		
		可以用tonumber(string)将一个字符串显示转成数字，不过转换不成功返回 nil
		可以用tostring(number)将一个数字显示的转成字符串
		
	table类型
		它是一个关联数组，可以通过一个大括号创建它{}
		a = {}
		可以用点和[]来赋值
		a["x"] = 10
		a.x = 10 -->等同于a["x"]
		#a 可以得到table a 的长度
		
6.解释器程序
	命令:
	_PROMPT='命令提示符' 默认的是 >
	
	如果要打印表达式的值，可以用等号开头，并跟随一个表达式如
	>= math.sin(3)
	0.14112000805987
	>a = 30
	>=a
	30

7.表达式
	算术操作符
	+ - * / ^(指数) %(取模) -(负数)
	取模公式
	a%b = a - math.floor(a/b)*b
	X%1 表示X的小数部分 X-X%1 表示X的整数部分
	X%0.01 表示精确到小数点后面两位
	
	关系操作符
	< > <= >= == ~=(不等)
	关系操作符返回的都是boolean类型
	
	逻辑操作符
	and or not
	对于and 第一个操作数为假就返回第一个操作数，否则返回第二个操作数
	对于or  第一个操作数为真就返回第一个操作数，否则返回第二个操作数
	对于not 只返回true或者false
	
	字符串连接
	..
	print("hello" .. "world") -->hello world
	print(0 .. 1) -->01
	
	长度操作符
	#
	可以用于字符串和talbe
	a[#a + 1] = "v";
	#只能表示连续的长度,当碰到nil时，它就认为结束了
	a = {}
	a[1] = 1
	a[2] =nil
	a[3] = 3
	print(#a) -->1
	
	b = {}
	b["x"] = 10
	b["y"] = 20
	print(#b) -->0
	
	优先级
	^
	not # -(一元)
	* / %
	+ -
	..
	< > <= >= ~= ==
	and
	or
	
	除了^ 和 .. 操作符是右结合之外，其他操作符都是左结合。  
	右结合性：意思是从右向左执行运算；例如
	a=b=c，按a=（b=c）运算，
	左结合性：意思是从左向右执行运算；例如
	a+b+c，按（a+b）+c运算
	
	Table 构造式
	table 假如没有指定键值，默认是从 1 开始
	polyline = {color="blue", 3,thickness=2, npoints=4, {x=0, y=0},{x=-10,y=10},{x=9,2}}
	print(polyline[1]) -->3
	print(polyline[3].x) --> -10
	print(polyline[4][1]) --> 2
	
	table 还能用表达式来构造和访问建， 用一个[] 来表示
	opnames = {["-"] = "sub"}
	i = 20
	s = "-"
	a = {[i+2] = s..s..s}
	print(opnames[s]) -->sub
	print(a[22]) --> ---
	
	另外构造式用可以用分号;代替,来分隔不同元素
	{x=10,y=45;"one","two"}

8.语句
	赋值
	多重赋值，将多个值赋予多个变量，每个值和变量之间用逗号分隔。
	先对=号右边所有元素求值，然后再进行赋值。如果变量的个数多于值的个数
	多的变量就是赋值为nil；如果值的个数多于变量的个数，多的值就会被丢掉。
	a, b = 10, 2*x
	
	局部变量和块（作用域）
	局部变量的声明
	local i = 1
	它的作用域有四个地方
	1.函数体内
	2.控制结构体内
	3.一个文件内
	4.同一字串命令。比如在交互模式中，即在交互模式中每一行就是一个块。
	>local i = 1 -->这个代表一个块，作用域就只在这个块中
	>print(i) -->nil
	但是在同一行
	>local i = 1 print(i) --> 1  整个字串代表一个块
	5.do end 之间，可适用于交互模式
	do
		local a = 10
		print(a)
	end
	局部变量多重赋值，其特性和全局变量多重赋值一样，只是需要在最开始加上local 标识
	local a, b = 1, 2
	
9.控制结构
	条件结构
	1.if then else
		if a < 0 then 
			a = 0
		end
		
		if a<0 then 
			return a
		else
			return 0
		end
	
	2.if elseif
		if op == "+" then
			return 1
		elseif op == "-" then
			return -1
		else
			return 0
		end
		
	循环结构
	1.while do
		while i < 10 do
			i++
		end
	
	2.repeat until 注意在repeat中声明的临时变量 依然可以用在条件判断中
		local k = 1
		repeat
			local i = 10
			i = i - k
			k = k + 1
			print(i)
		until i < 0
		
	3.数字型 for
		for var = exp1, exp2, exp3 do
			<...>
		end
		其中exp3可以不写，默认为1，var 会被自动声明为for的局部变量
		for i = 1, f(x), -1 do
			print(i)
		end
	
	4.泛型 for
		for i,v in ipairs(array)
			<...>
		end
		每次循环，i被赋值一个索引，v被赋值该索引的值
		迭代器的种类:
		io.lines 		迭代文件中的每行
		pairs 	 		迭代table元素
		ipairs	 		迭代数组元素
		stirng.gmatch	迭代字符串中的字母
	
	5.break return goto
		break 用来跳出最内层的循环，并继续执行函数
		return 用来结束函数
		break 和 return 只能是一个块的最后一条语句，或者是end，else，until 前一条语句。
		如果要在中间插入return 或 break 可以用do end 来包装
		
		function foo()
			return 		-->不会报错，但是会忽略这个return
			print(2)
		end
		
		function foo()
			do return end --> 正确做法应该用 do end 来包装
			print(2)
		end
		
		goto语句可以跳到一个指定的标签
		标签的定义 ::标签名字::
		限制条件:
		1. goto 不能跳到一个块里面去，因为块中的label对外是不可见的
		2. goto 不能跳出一个function
		3. goto 不能跳入一个局部变量的范围
		例：
		::s1::do
		local c = 1
		print(1)
		end
		goto s1

10.函数
	定义
	function add (参数1,参数2)
		return 返回1,返回2
	end
	
	调用
	add(1,2)
	假如函数只有一个参数，并且此参数是一个字面字符串或者一个table构造式，
	那么调用的时候可以不写圆括号
	print "hello"
	dofile "1.lua"
	print [[a multi-line message]]
	type{}
	
	传值
	可以传任意值，但是会按照变量赋值法则来为形参赋值
	
	默认值
	function f(n)
		n = n or 1 -->表示n的默认值是1
	end
	
	多重返回值
	函数可以返回多个值，当函数作为语句的时候，它会丢掉所有返回值；
	当函数作为表达式的时候，它会保留第一个值，只有当它是一系列表达式的
	最后一条是，才会保留所有值。
	一系列表达是指一下4种情况
	1.多重赋值的时候
	2.函数调用时传入的实参列表
	3.table的构造式
	4.return 语句
	
	将一个函数表达式放入一个圆括号，可以迫使它只返回一个值
	print((foo2())) -->a
	
	table.unpack()函数
	talbe.unpack({...})函数接受一个数组作为参数，默认从下标1开始返回该
	数组的所有元素。也可以指定它返回哪几个参数。
	print(table.unpack({"sun","mon","tue","wed"},2,3)) -->mon tue
	所以它的最大用处是泛型调用？？？(好像还是没毛用)
	unpack 可以用递归实现
	function unpack(t,i,n)
		i = i or 1
		n = n or #t
		if i<=n then
			return t[i], unpack(t, i+1, n)
		end
	end
	
	可变形参
	function add(...)
		local s = 0
		for i, v in ipairs{...} do
			s = s+v
		end
		return s
	end
	
	...表示函数可以接受不同数量的实参。一个函数要访问它的可变参数时任要用到3个点，
	此时 ... 是作为表达式存在的
	local a ,b = ...
	
	可变形参函数也可以拥有固定形参，但是固定形参一定要在...之前
	
	如果要遍历形参，可以使用函数table.pack(...)，这个函数可以接受任意数量的参数，
	并且返回一个新的table携带着这些参数， 这个新的table 有一个额外的字段 n 用来表示
	有多少个参数。
	function foo(...)
		local arg = table.pack(...)
		for i = 1, arg.n do 
			print(arg[i])
		end
	end

	foo(1,nil,2) -->1 nil 2
	foo(1,2,nil) -->1,2,nil
	
	函数参数默认值
	传入table可以使参数具有默认值
	function _foo(title, width, height)
		print(title,width,height)
	end

	function foo(options)
		if type(options.title) ~= "string" then
			options.title = "no title"
		elseif type(options.width) ~= "number" then
			options.width = 100
		elseif type(options.height) ~= "number" then
			options.height = 100
		end
		
		_foo(options.title, options.width, options.height)
	end

	foo({title="hh",width=400,height=600})
	foo({})
	
	深入理解函数
	function 是一种类型，所以他可以向普通类型那个声明和赋值，一定要记住这段话
	function foo(x) return 2*x end
	foo = function (x) return 2*x end
	上述两种情况是等价的
	匿名函数
	function derivative(f, delta)
		delta = delta or 1e-4
		return function(x)
					return (f(x+delta) - f(x))/delta
				end
	end
	c = derivative(math.sin)
	print(math.cos(5.2), c(5.2)) --> 0.46851667130038        0.46856084325086
	print(math.cos(10),c(10)) --> -0.83907152907645       -0.83904432662041

	闭合函数
	function newCounter()
		local i = 0
		return function ()
				i = i + 1
				return i
				end
	end
	
	c1 = newCounter()
	print(c1()) --> 1
	print(c1()) --> 2
	
	c2 = newCounter()
	print(c2()) --> 1
	print(c1()) --> 3
	print(c2()) --> 2
	
	注意其中的i值，被闭合的函数（闭合函数）拥有了使它成为闭合函数（宿主函数）的局部变量，此时i 变成了一个非局部变量，
	它既不是全局变量，因为不能被除了闭合函数的其他对象访问；它也不是局部变量，因为对于
	闭合函数而言它是相当于是个全局的数据。
	每次运行宿主函数的时候，非局部变量，都会为此次运行的结果开辟一个新的空间用来保存新的非局部变量。
	
	将一个老函数变成新函数的办法
	function f(a)
		return a
	end

	do
		local oldSin = f
		local k = 10
		f = function(x)
			return oldSin(x*k)
		end
	end

	print(f(1)) --> 10
	
	非全局函数
	Lib = {}
	Lib.foo = function (x, y) return x + y end
	Lib.goo = function (x, y) return x - y end
	
	print(Lib.foo(2,3),Lib.goo(2,3)) --> 5
	
	Lib = {foo = function (x, y) return x + y end,  
			goo = function (x, y) return x - y end}
			
	Lib = {}
	function Lib.foo(x, y) return x + y end
	function Lib.goo(x, y) return x - y end
	
	局部函数
	定义
	local f = function(<params>)
				<body>
				end
		
	local function f(<params>)
		<body>
	end
	
	另外注意：
	local fact = function(n)
			if n == 0  then return 1
			else return n*fact(n-1) -->error
			end
		end
	这样编译器是通不过的，语法层面就通不过了，参考C/C++
	应该先声明，再定义，因为再实际运行的时候，fact已经有正确的值了。
	local fact
	fact = function(n)
			if n == 0  then return 1
			else return n*fact(n-1) -->error
			end
		end
	
	这种定义，与先声明再赋值是一个效果
	local function foo(<params>) <body> end 
	等价于
	local foo; foo = function(<params>) <body> end 
	
	尾调函数
	当一个函数调用是另一个函数调用的最后一个函数的时候，会进行尾部调用，
	（很绕口是不是，听不懂是不是，没关系，一句话解释清楚）把它当内联函数处理就行了
	function f(x) return g(x) end
	return x[i].foo(x[j] + a*b, i+j)
	上述两种情形会发生尾部调用
	
11.迭代和泛型for
	首先看看迭代器的实现
	迭代器就是一个种可以遍历集合中所有元素的机制。
	function values(t)
		local i = 0
		return function () i = i+1; return t[i] end
	end
	使用迭代器
	t = {10,20,30}
	iter = values(t)
	while true do
		local element = iter()
		if(element == nil) then break end
		print(element)
	end
	
	
	泛型 for 语法
	for <var-list> in <exp-list> do
		<body>
	end
	例：
	for k, v in pairs(t) do print(k, v) end
	
	泛型for保存了3个值
	1.迭代器函数
	2.控制变量（var-list）中的第一个变量，称为控制变量，一旦它为nil则循环结束
	3.恒定状态 （就是传入的table，数组等等之类的东东）
	具体，见下详解：
	for var_1, ..., var_n in <exp-list> do <body> end
	等价于
	迭代器函数是 _function ,恒定状态是 _state, 控制变量是 _var
	do
		local _function, _state, _var = <exp-list>
		while true do 
			local var_1,...,var_n = _function(_state, _var)
			_var = var_1
			if _var == nil then break end
		end
	end
	控制变量的初值为 a0,  循环过程中控制变量的初始依次为 a1=_function(_state,a0), a2=_function(_state, a1),....以此类推, 直到ai为nil结束循环。如果for循环还有其他变量，那么这些变量也会在每次调用_function后获得额外的值
	
	无状态的迭代器
	a = {"one", "two","three"}
	for i, v in ipairs(a) do
		print(i, v)
	end
	
	local function iter(a, i)
		i = i +1
		local v = a[i]
		if v then 
			return i, v
		end
	end
	
	function ipairs(a)
		return iter, a, 0
	end
	
	ipairs 返回了1. 迭代器，2. 恒定状态 a ，3.变量初值 0
	还有一个next函数的解释详见书籍。
	复杂状态的迭代器 和 真正的迭代器 详见书本。（这部分不理解）
	
	
12.编译，执行和错误
	Lua会先编译生成中间码，然后再去解释执行代码。
	编译型语言和解释型语言的区别在于能否动态的执行代码。
	
	loadfile 和 dofile
	loadfile 仅仅是编译文件，并且返回编译结果（相当于返回一个函数）
	loadfile可以用一个函数来接受
	f = loadfile(filename)
	f()
	
	与loadfile 一样的还有 load 不同的是 load 执行的是一个string
	f = load("i = i + 1")
	f(...) i = i + 1 end
	
	dofile 不仅编译文件，还执行
	dofile 的原型相当于
	function dofile(filename)
		local f = assert(loadfile(filename))
		return f()
	end

	预编译代码
	-o生成预编译文件 2.lc
	$luac -o 2.lc 2.lua
	可以直接执行lc文件
	$lua 2.lc
	
	loadefile 和 load 也能接受预编译之后的文件
	p = loadfile(arg[1])
	f = io.open(arg[2],"wb")
	f:wirte(string.dump(p))
	f:close()
	
	关键点是 string.dump：它可以接受一个lua 的 function 并且返回预编译码的字符串形式
	
	错误处理
	1.assert
	lua有一个内建的错误处理函数 assert
	assert 检查它的第一个参数不为假，并且返回这个参数。假如第一个参数为假，assert 就报一个
	错误。它的第二个参数是一个提示信息，是可选的。	如果assert的第一个参数为不为false，则返回第一个参数的值；否则，执行error函数，输出错误信息，错误信息的内容为assert的第二个参数。
	
	错误捕获
	2.pcall
	pcall调用一个函数并且返回true或false
	注意只有当这个函数中包含有error时才会返回false
	例：
	假如没有hh文件
	function test()
		file = assert(io.open("hh","r"),"ccc")
	end

	local b = pcall(test)
	print(b) --> false
	因为assert里面包含了，error调用，所有会是false
	
	如果换这种写法
	function test()
		io.open("hh","r")
	end

	local b = pcall(test)
	print(b) --> true
	由于没有error调用所以返回true

	同理
	function test()
		print("c")
		error()
	end

	local b = pcall(test)
	print(b) -->false
	
	显示传出errorcode，用第二个参数来接一个table值
	function test()
		print("c")
		error({code=11}) --> pcall调用时传出了这个table，这个table可以随意赋值
	end

	local b,c = pcall(test)
	print(b) --> false
	print(c.code) --> 11
	
	
	错误消息和追溯
	error 的第二个参数可以表示再那一层级显示错误消息
	function foo (str)
		if type(str) ~= "string" then
			error("a",1)
		end
		print(str)
	end

	foo(12) --> 2.lua:3: a 
	-----------------------------------
	function foo (str)
		if type(str) ~= "string" then
			error("a",2)
		end
		print(str)
	end

	foo(12) --> 2.lua:8: a
	-----------------------------------
	function foo (str)
		if type(str) ~= "string" then
			error("a",3)
		end
		print(str)
	end

	function test ()
	foo(12)
	end

	test() --> 2.lua:12: a
	-----------------------------------
	但是如果用pcall来运行foo则不会提示哪里出错。pcall返回时，它已经销毁了调用桟的部分内容。
	function foo (str)
		if type(str) ~= "string" then
			error("a",2)
		end
		print(str)
	end

	b,c = pcall(foo, {x = 1})
	print(c) --> a
	
	为了解决这个问题，可以用另一个函数 xpcallxpcall接收第二个参数——一个错误处理函数，当错误发生时，Lua会在调用桟展看（unwind）前调用错误处理函数，于是就可以在这个函数中使用debug库来获取关于错误的额外信息了。
	debug库提供了两个通用的错误处理函数:
	debug.debug：提供一个Lua提示符，让用户来价差错误的原因
	debug.traceback：根据调用桟来构建一个扩展的错误消息
	
	function foo (str)
		if type(str) ~= "string" then
			error("a",2)
		end
		print(str)
	end

	b,c = xpcall(foo, function()print(debug.traceback())end,{x = 1})
	print(c)
	
	stack traceback:
        2.lua:8: in function <2.lua:8>
        [C]: in function 'error'
        2.lua:3: in function 'foo'
        [C]: in function 'xpcall'
        2.lua:8: in main chunk
        [C]: in function 'dofile'
        stdin:1: in main chunk
        [C]: in ?
	nil

13.协同程序
	协程是单线程执行的，每次只运行一个协同程序。
	协程有4中状态：挂起（暂停），运行，结束和正常
	当我们创建一个新的协程的时候coroutine.create(function)，它处于 挂起 状态；
	当我们调用调用 coroutine.resume(co) 的时候它的状态从 挂起 转到 运行
	当一个协程coroutine.resume 其他协程时，当前协程不会被挂起，它的状态变为normal状态
	当协程运行结束的时候，它的状态变为 结束
	查看协程状态 coroutine.status(co)
	
	coroutine.yield()可以让协程从 运行状态变为 挂起 状态
	
	coroutine.resume(co)采用了保护模式，它本身是不报错的，但是resume会返回错误。
	co = coroutine.create(function() 
							for i = 1, 3, 1 
							do 
								print(i)
								coroutine.yield()
							end 
						end)
	coroutine.resume(co) --> 1
	print(coroutine.resume(co)) --> 2	true
	coroutine.resume(co) --> 3
	print(coroutine.resume(co)) --> true
	print(coroutine.resume(co)) --> false   cannot resume dead coroutine
	
	resume 和 yield 的数据交换
	resume可以接受数据传入
	co = coroutine.create(function(a,b) 
							print(a,b)
						end)
	coroutine.resume(co, 10,20) --> 10 20

	当协程结束的时候，resume返回程序结束时应该返回的值
	co = coroutine.create(function() 
							return 10,20
						end)
	print(coroutine.resume(co)) -->true 10 20

	coroutine.yield 会返回 coroutine.resume 传入的数据
	co = coroutine.create(function(a,b) 
							coroutine.yield(a+b, a-b)
						end)
	print(coroutine.resume(co, 10,20)) --> 30 -10


	co = coroutine.create(function (x)
							print("co1",x)
							print("co2", coroutine.yield())
						end)
	coroutine.resume(co, "hi") --> co1 hi
	coroutine.resume(co, 4, 5) --> co2 4, 5
		
14. 数据结构
	请参看书籍第11章。
	
	关于StringBuffer 对应的替代就是 table.concat, 第一个参数是要连接的table，第二个是如何分割这些字符（就是在每个字符的后面加上这个字符串）
	local t = {}
	for line in io.lines() do
		t[#t + 1] = line
	end
	local s = table.concat(t,"\t")
	print(s)

15. 数据文件和持久性
	书中第一节讲解了，给输入字符串加引号的问题，不知道是什么用意。
	有两种方法:
	1.string.format("%q", o)
	function serialize(o)
		if type(o) == "string" then
			print(string.format("%q", o)) --> 假如o是5则显示"5"
		end
	end
	
	2. 用[=[ ]=], 但这种情况只适合文本不变的时候，固定文本的时候。因为没办法自动组织括号里面的内容。
	用长字符串块
	function serialize(o)
		if type(o) == "string" then
			print([=["o"]=]) --> "o"
		end
	end
	
	接着书又讲了，table怎么写入文件
	分两种情况
	1. table中没有嵌套table
	2. table中有嵌套table
	具体实践中应该能自己解决
	
16. 元表和元方法
	除非使用元表，否则我们不能使tables相加，不能比较function，也不能调用一个字符串
	当一个值执行一个没有定义的操作的时候，元表允许我们改变它的行为。
	lua在创建新的table时是没有元表的
	我们可以用 setmetatable 来设置元表
	t = {}
	setmetatable(t, t1)
	print(getmetatable(t) == t1) --> true
	
	我们只能设置table的元表， 设置其他类型的元表我们必须使用 C 代码。
	string库为string类型设置了一个元表， 其他类型默认没有元表
	print(getmetatable("hi")) --> table: 00000000004b9730
	任何table都可以作为其他值的元表；一系列的相关tables可以共享一个元表；一个table可以是它自己的元表；
	
	
	运算元方法
	__add, __sub, __mul, __div, __mod, __pow
	
	local mt = {}
	Set = {}

	function Set.new(l)
		local set = {}
		setmetatable(set, mt)
		for _, v in ipairs(l) do set[v] = true end
		return set
	end

	function Set.union(a, b)
		local res = Set.new{}
		for k in pairs(a) do res[k] = true end
		for k in pairs(b) do res[k] = true end
		return res
	end

	function Set.intersection(a,b)
		local res = Set.new{}
		for k in pairs(a) do
			res[k] = b[k]
		end
		return res
	end

	function Set.tostring(set)
		local l = {}
		for e in pairs(set) do
			l[#l+1] = e
		end
		return "{" .. table.concat(l,", ") .. "}"
	end

	function Set.print(s)
		print(Set.tostring(s))
	end
	--指定相加的方法
	mt.__add = Set.union
	--指定相乘的方法
	mt.__mul = Set.intersection
	s1 = Set.new{10,20,30,50}
	s2 = Set.new{32,1}
	s3 = s1 + s2
	print(getmetatable(s1)) --> table: 00000000004b9e30
	print(getmetatable(s2))	--> table: 00000000004b9e30
	s4 = s3*s2
	Set.print(s3)
	Set.print(s4)
	
	已__add为例
	假如第一个值有元表，并且元表包含__add 字段，那么lua用这个字段作为元方法，而不依赖于第二个值；
	否则，假如第二个值有元表，并且元表包含__add，那么lua用这个字段作为元方法；
	否则，两个值都没有元表，或者元表都不包含__add， 那么lua会报错。
	只要有__add那么lua不会关心你和什么值相加，它只关心你的函数能不能处理这个值，如果不能处理它会在函数处理的那个阶段报错，而不是在 "+" 号这里报错
	
	
	关系元方法
	__eq, __lt, __le
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	